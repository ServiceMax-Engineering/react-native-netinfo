{"version":3,"sources":["internetReachability.ts"],"names":["InternetReachability","configuration","listener","_isInternetReachable","undefined","_currentInternetReachabilityCheckHandler","_currentTimeoutHandle","_setIsInternetReachable","isInternetReachable","_listener","_setExpectsConnection","expectsConnection","cancel","clearTimeout","_checkInternetReachability","responsePromise","fetch","_configuration","reachabilityUrl","method","cache","timeoutHandle","timeoutPromise","Promise","_","reject","setTimeout","reachabilityRequestTimeout","cancelPromise","promise","race","then","response","reachabilityTest","result","nextTimeoutInterval","reachabilityLongTimeout","reachabilityShortTimeout","catch","error","update","state","isConnected","currentState","tearDown"],"mappings":"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","sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n */\r\n\r\nimport * as Types from './types';\r\nimport * as PrivateTypes from './privateTypes';\r\n\r\ninterface InternetReachabilityCheckHandler {\r\n  promise: Promise<void>;\r\n  cancel: () => void;\r\n}\r\n\r\nexport default class InternetReachability {\r\n  private _configuration: Types.NetInfoConfiguration;\r\n  private _listener: PrivateTypes.NetInfoInternetReachabilityChangeListener;\r\n  private _isInternetReachable: boolean | null | undefined = undefined;\r\n  private _currentInternetReachabilityCheckHandler: InternetReachabilityCheckHandler | null = null;\r\n  private _currentTimeoutHandle: ReturnType<typeof setTimeout> | null = null;\r\n\r\n  constructor(\r\n    configuration: Types.NetInfoConfiguration,\r\n    listener: PrivateTypes.NetInfoInternetReachabilityChangeListener,\r\n  ) {\r\n    this._configuration = configuration;\r\n    this._listener = listener;\r\n  }\r\n\r\n  private _setIsInternetReachable = (\r\n    isInternetReachable: boolean | null | undefined,\r\n  ): void => {\r\n    if (this._isInternetReachable === isInternetReachable) {\r\n      return;\r\n    }\r\n\r\n    this._isInternetReachable = isInternetReachable;\r\n    this._listener(this._isInternetReachable);\r\n  };\r\n\r\n  private _setExpectsConnection = (expectsConnection: boolean): void => {\r\n    // Cancel any pending check\r\n    if (this._currentInternetReachabilityCheckHandler !== null) {\r\n      this._currentInternetReachabilityCheckHandler.cancel();\r\n      this._currentInternetReachabilityCheckHandler = null;\r\n    }\r\n    // Cancel any pending timeout\r\n    if (this._currentTimeoutHandle !== null) {\r\n      clearTimeout(this._currentTimeoutHandle);\r\n      this._currentTimeoutHandle = null;\r\n    }\r\n\r\n    if (expectsConnection) {\r\n      // If we expect a connection, start the process for finding if we have one\r\n      // Set the state to \"null\" if it was previously false\r\n      if (!this._isInternetReachable) {\r\n        this._setIsInternetReachable(null);\r\n      }\r\n      // Start a network request to check for internet\r\n      this._currentInternetReachabilityCheckHandler = this._checkInternetReachability();\r\n    } else {\r\n      // If we don't expect a connection, just change the state to \"false\"\r\n      this._setIsInternetReachable(false);\r\n    }\r\n  };\r\n\r\n  private _checkInternetReachability = (): InternetReachabilityCheckHandler => {\r\n    const responsePromise = fetch(this._configuration.reachabilityUrl, {\r\n      method: 'HEAD',\r\n      cache: 'no-cache',\r\n    });\r\n\r\n    // Create promise that will reject after the request timeout has been reached\r\n    let timeoutHandle: ReturnType<typeof setTimeout>;\r\n    const timeoutPromise = new Promise<Response>((_, reject): void => {\r\n      timeoutHandle = setTimeout(\r\n        (): void => reject('timedout'),\r\n        this._configuration.reachabilityRequestTimeout,\r\n      );\r\n    });\r\n\r\n    // Create promise that makes it possible to cancel a pending request through a reject\r\n    let cancel: () => void = (): void => {};\r\n    const cancelPromise = new Promise<Response>((_, reject): void => {\r\n      cancel = (): void => reject('canceled');\r\n    });\r\n\r\n    const promise = Promise.race([\r\n      responsePromise,\r\n      timeoutPromise,\r\n      cancelPromise,\r\n    ])\r\n      .then(\r\n        (response): Promise<boolean> => {\r\n          return this._configuration.reachabilityTest(response);\r\n        },\r\n      )\r\n      .then((result): void => {\r\n        this._setIsInternetReachable(result);\r\n        const nextTimeoutInterval = this._isInternetReachable\r\n          ? this._configuration.reachabilityLongTimeout\r\n          : this._configuration.reachabilityShortTimeout;\r\n        this._currentTimeoutHandle = setTimeout(\r\n          this._checkInternetReachability,\r\n          nextTimeoutInterval,\r\n        );\r\n      })\r\n      .catch((error: Error | 'timedout' | 'canceled'): void => {\r\n        if (error !== 'canceled') {\r\n          this._setIsInternetReachable(false);\r\n          this._currentTimeoutHandle = setTimeout(\r\n            this._checkInternetReachability,\r\n            this._configuration.reachabilityShortTimeout,\r\n          );\r\n        }\r\n      })\r\n      // Clear request timeout and propagate any errors\r\n      .then(\r\n        (): void => {\r\n          clearTimeout(timeoutHandle);\r\n        },\r\n        (error: Error): void => {\r\n          clearTimeout(timeoutHandle);\r\n          throw error;\r\n        },\r\n      );\r\n\r\n    return {\r\n      promise,\r\n      cancel,\r\n    };\r\n  };\r\n\r\n  public update = (state: PrivateTypes.NetInfoNativeModuleState): void => {\r\n    if (typeof state.isInternetReachable === 'boolean') {\r\n      this._setIsInternetReachable(state.isInternetReachable);\r\n    } else {\r\n      this._setExpectsConnection(state.isConnected);\r\n    }\r\n  };\r\n\r\n  public currentState = (): boolean | null | undefined => {\r\n    return this._isInternetReachable;\r\n  };\r\n\r\n  public tearDown = (): void => {\r\n    // Cancel any pending check\r\n    if (this._currentInternetReachabilityCheckHandler !== null) {\r\n      this._currentInternetReachabilityCheckHandler.cancel();\r\n      this._currentInternetReachabilityCheckHandler = null;\r\n    }\r\n\r\n    // Cancel any pending timeout\r\n    if (this._currentTimeoutHandle !== null) {\r\n      clearTimeout(this._currentTimeoutHandle);\r\n      this._currentTimeoutHandle = null;\r\n    }\r\n  };\r\n}\r\n"]}